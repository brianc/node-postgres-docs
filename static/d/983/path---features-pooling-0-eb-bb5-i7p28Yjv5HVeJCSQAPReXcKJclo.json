{"data":{"site":{"siteMetadata":{"title":"node-postgres","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"c6ee0836-2f1c-5855-b28b-6384135e1e24","title":"Pooling","slug":"/features/pooling"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Pooling\",\n  \"slug\": \"/features/pooling\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you're working on a web application or other software which makes frequent queries you'll want to use a connection pool.\"), mdx(\"p\", null, \"The easiest and by far most common way to use node-postgres is through a connection pool.\"), mdx(\"h2\", null, \"Why?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Connecting a new client to the PostgreSQL server requires a handshake which can take 20-30 milliseconds. During this time passwords are negotiated, SSL may be established, and configuration information is shared with the client & server. Incurring this cost \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"every time\"), \" we want to execute a query would substantially slow down our application.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The PostgreSQL server can only handle a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://wiki.postgresql.org/wiki/Number_Of_Database_Connections\"\n  }), \"limited number of clients at a time\"), \". Depending on the available memory of your PostgreSQL server you may even crash the server if you connect an unbounded number of clients. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I have crashed a large production PostgreSQL server instance in RDS by opening new clients and never disconnecting them in a python application long ago. It was not fun.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"PostgreSQL can only process one query at a time on a single connected client in a first-in first-out manner. If your multi-tenant web application is using only a single connected client all queries among all simultaneous requests will be pipelined and executed serially, one after the other. No good!\"))), mdx(\"h3\", null, \"Good news\"), mdx(\"p\", null, \"node-postgres ships with built-in connection pooling via the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }), \"pg-pool\"), \" module.\"), mdx(\"h2\", null, \"Examples\"), mdx(\"p\", null, \"The client pool allows you to have a reusable pool of clients you can check out, use, and return. You generally want a limited number of these in your application and usually just 1. Creating an unbounded number of pools defeats the purpose of pooling at all.\"), mdx(\"h3\", null, \"Checkout, use, and return\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\n// the pool with emit an error on behalf of any idle clients\\n// it contains if a backend error or network partition happens\\npool.on('error', (err, client) => {\\n  console.error('Unexpected error on idle client', err)\\n  process.exit(-1)\\n})\\n\\n// callback - checkout a client\\npool.connect((err, client, done) => {\\n  if (err) throw err\\n  client.query('SELECT * FROM users WHERE id = $1', [1], (err, res) => {\\n    done()\\n\\n    if (err) {\\n      console.log(err.stack)\\n    } else {\\n      console.log(res.rows[0])\\n    }\\n  })\\n})\\n\\n// promise - checkout a client\\npool\\n  .connect()\\n  .then(client => {\\n    return client\\n      .query('SELECT * FROM users WHERE id = $1', [1])\\n      .then(res => {\\n        client.release()\\n        console.log(res.rows[0])\\n      })\\n      .catch(e => {\\n        client.release()\\n        console.log(err.stack)\\n      })\\n  })(\\n    // async/await - check out a client\\n    async () => {\\n      const client = await pool.connect()\\n      try {\\n        const res = await client.query('SELECT * FROM users WHERE id = $1', [1])\\n        console.log(res.rows[0])\\n      } finally {\\n        client.release()\\n      }\\n    }\\n  )()\\n  .catch(e => console.log(e.stack))\\n\")), mdx(\"div\", {\n    className: \"message is-danger\"\n  }, mdx(\"div\", {\n    className: \"message-body\"\n  }, \"You must __always__ return the client to the pool if you successfully check it out, regardless of whether or not there was an error with the queries you ran on the client.  If you don't check in the client your application will leak them and eventually your pool will be empty forever and all future requests to check out a client from the pool will wait forever.\")), mdx(\"h3\", null, \"Single query\"), mdx(\"p\", null, \"If you don't need a transaction or you just need to run a single query, the pool has a convenience method to run a query on any available client in the pool. This is the preferred way to query with node-postgres if you can as it removes the risk of leaking a client.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\npool.query('SELECT * FROM users WHERE id = $1', [1], (err, res) => {\\n  if (err) {\\n    throw err\\n  }\\n\\n  console.log('user:', res.rows[0])\\n})\\n\")), mdx(\"p\", null, \"node-postgres also has built-in support for promises throughout all of its async APIs.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\npool\\n  .query('SELECT * FROM users WHERE id = $1', [1])\\n  .then(res => console.log('user:', res.rows[0]))\\n  .catch(e =>\\n    setImmediate(() => {\\n      throw e\\n    })\\n  )\\n\")), mdx(\"p\", null, \"Promises allow us to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" in node v8.0 and above (or earlier if you're using babel).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\nconst pool = new Pool()(async () => {\\n  const { rows } = await pool.query('SELECT * FROM users WHERE id = $1', [1])\\n  console.log('user:', rows[0])\\n})().catch(e =>\\n  setImmediate(() => {\\n    throw e\\n  })\\n)\\n\")), mdx(\"h3\", null, \"Shutdown\"), mdx(\"p\", null, \"To shut down a pool call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.end()\"), \" on the pool. This will wait for all checked-out clients to be returned and then shut down all the clients and the pool timers.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\nconst pool = new Pool()\\n\\n(async () => {\\n  console.log('starting async query')\\n  const result = await pool.query('SELECT NOW()')\\n  console.log('async query finished)\\n\\n  console.log('starting callback query')\\n  pool.query('SELECT NOW()', (err, res) => {\\n    console.log('callback query finished')\\n  })\\n\\n  console.log('calling end')\\n  await pool.end()\\n  console.log('pool has drained')\\n})()\\n\")), mdx(\"p\", null, \"The output of the above will be:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"starting async query\\nasync query finished\\nstarting callback query\\ncalling end\\ncallback query finished\\npool has drained\\n\")), mdx(\"div\", {\n    className: \"message is-warning\"\n  }, mdx(\"div\", {\n    className: \"message-body\"\n  }, \"The pool will return errors when attempting to check out a client after you've called `pool.end()` on the pool.\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"tableOfContents":{"items":[{"url":"#why","title":"Why?","items":[{"url":"#good-news","title":"Good news"}]},{"url":"#examples","title":"Examples","items":[{"url":"#checkout-use-and-return","title":"Checkout, use, and return"},{"url":"#single-query","title":"Single query"},{"url":"#shutdown","title":"Shutdown"}]}]},"parent":{"__typename":"File","relativePath":"features/3-pooling.mdx"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/announcements","title":"Announcements"}}},{"node":{"fields":{"slug":"/","title":"Welcome"}}},{"node":{"fields":{"slug":"/api","title":"API"}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Async Express"}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading"}}},{"node":{"fields":{"slug":"/features/connecting","title":"Connecting"}}},{"node":{"fields":{"slug":"/features/queries","title":"Queries"}}},{"node":{"fields":{"slug":"/transactions","title":"Transactions"}}},{"node":{"fields":{"slug":"/features/types","title":"Data Types"}}},{"node":{"fields":{"slug":"/api/pool","title":"pg.Pool"}}},{"node":{"fields":{"slug":"/api/result","title":"pg.Result"}}},{"node":{"fields":{"slug":"/api/2-client","title":"pg.Client"}}},{"node":{"fields":{"slug":"/features/ssl","title":"SSL"}}},{"node":{"fields":{"slug":"/features/native","title":"Native Bindings"}}},{"node":{"fields":{"slug":"/api/cursor","title":"pg.Cursor"}}},{"node":{"fields":{"slug":"/api/4-types","title":"Types"}}},{"node":{"fields":{"slug":"/features/pooling","title":"Pooling"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"c6ee0836-2f1c-5855-b28b-6384135e1e24"}}