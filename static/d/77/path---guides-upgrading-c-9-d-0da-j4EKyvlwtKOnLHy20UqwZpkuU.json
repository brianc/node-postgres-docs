{"data":{"site":{"siteMetadata":{"title":"node-postgres","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"0275f5cc-b71d-5f93-bd9d-e231a85901c5","title":"Upgrading","slug":"/guides/upgrading"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Upgrading to 7.0\"), mdx(\"p\", null, \"node-postgres at 7.0 introduces somewhat significant breaking changes to the public API.\"), mdx(\"h2\", null, \"node version support\"), mdx(\"p\", null, \"Starting with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \" the earliest version of node supported will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node@4.x LTS\"), \".  Support for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node@0.12.x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node@.10.x\"), \" is dropped, and the module wont work as it relies on new es6 features not available in older versions of node.\"), mdx(\"h2\", null, \"pg singleton\"), mdx(\"p\", null, \"In the past there was a singleton pool manager attached to the root \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg\"), \" object in the package.  This singleton could be used to provision connection pools automatically by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg.connect\"), \".  This API caused a lot of confusion for users.  It also introduced a opaque module-managed singleton which was difficult to reason about, debug, error-prone, and inflexible.  Starting in pg@6.0 the methods' documentation was removed, and starting in pg@6.3 the methods were deprecated with a warning message.\"), mdx(\"p\", null, \"If your application still relies on these they will be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"gone\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \".  In order to migrate you can do the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// old way, deprecated in 6.3.0:\\n\\n// connection using global singleton\\npg.connect(function(err, client, done) {\\n  client.query(/* etc, etc */)\\n  done()\\n})\\n\\n// singleton pool shutdown\\npg.end()\\n\\n// ------------------\\n\\n// new way, available since 6.0.0:\\n\\n// create a pool\\nvar pool = new pg.Pool()\\n\\n// connection using created pool\\npool.connect(function(err, client, done) {\\n  client.query(/* etc, etc */)\\n  done()\\n})\\n\\n// pool shutdown\\npool.end()\\n\")), mdx(\"p\", null, \"node-postgres ships with a built-in pool object provided by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-pool\"\n  }), \"pg-pool\"), \" which is already used internally by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg.connect\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg.end\"), \" methods.  Migrating to a user-managed pool (or set of pools) allows you to more directly control their set up their life-cycle.\"), mdx(\"h2\", null, \"client.query(...).on\"), mdx(\"p\", null, \"Before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" method would \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"always\"), \" return an instance of a query.  The query instance was an event emitter, accepted a callback, and was also a promise.  A few problems...\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"too many flow control options on a single object was confusing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"event emitter \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".on('error')\"), \" does not mix well with promise \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".catch\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"row\"), \" event was a common source of errors: it looks like a stream but has no support for back-pressure, misleading users into trying to pipe results or handling them in the event emitter for a desired performance gain.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"error handling with a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".done\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".error\"), \" emitter pair for every query is cumbersome and returning the emitter from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"client.query\"), \" indicated this sort of pattern may be encouraged: it is not.\")), mdx(\"p\", null, \"Starting with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg@7.0\"), \" the return value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" will be dependent on what you pass to the method: I think this aligns more with how most node libraries handle the callback/promise combo, and I hope it will make the \\\"just works\\\" :tm: feeling better while reducing surface area and surprises around event emitter / callback combos.\"), mdx(\"h3\", null, \"client.query with a callback\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = client.query('SELECT NOW()', (err, res) => {\\n  /* etc, etc */\\n})\\nassert(query === undefined) // true\\n\")), mdx(\"p\", null, \"If you pass a callback to the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" will return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".  This limits flow control to the callback which is in-line with almost all of node's core APIs.\"), mdx(\"h3\", null, \"client.query without a callback\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = client.query('SELECT NOW()')\\nassert(query instanceof Promise) // true\\nassert(query.on === undefined) // true\\nquery.then((res) => /* etc, etc */)\\n\")), mdx(\"p\", null, \"If you do \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" pass a callback \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" will return an instance of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \".  This will \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" be a query instance and will not be an event emitter.  This is in line with how most promise-based APIs work in node.\"), mdx(\"h3\", null, \"client.query(Submittable)\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" has always accepted any object that has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".submit\"), \" method on it.  In this scenario the client calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".submit\"), \" on the object, delegating execution responsibility to it.  In this situation the client also \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"returns the instance it was passed\"), \".  This is how \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-cursor\"\n  }), \"pg-cursor\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-query-stream\"\n  }), \"pg-query-stream\"), \" work.  So, if you need the event emitter functionality on your queries for some reason, it is still possible because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" is an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Submittable\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client, Query } = require('pg')\\nconst query = client.query(new Query('SELECT NOW()'))\\nquery.on('row', (row) => {\\n\\n})\\nquery.on('end', (res) => {\\n\\n})\\nquery.on('error', (res) => {\\n\\n})\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" is considered a public, documented part of the API of node-postgres and this form will be supported indefinitely.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I have been building apps with node-postgres for almost 7 years.  In that time I have never used the event emitter API as the primary way to execute queries.  I used to use callbacks and now I use async/await.  If you need to stream results I highly recommend you use \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-cursor\"\n  }), \"pg-cursor\"), \" or \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-query-stream\"\n  }), \"pg-query-stream\"), \" and \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"not\"), \" the query object as an event emitter.\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"tableOfContents":{"items":[{"url":"#upgrading-to-70","title":"Upgrading to 7.0","items":[{"url":"#node-version-support","title":"node version support"},{"url":"#pg-singleton","title":"pg singleton"},{"url":"#clientqueryon","title":"client.query(...).on","items":[{"url":"#clientquery-with-a-callback","title":"client.query with a callback"},{"url":"#clientquery-without-a-callback","title":"client.query without a callback"},{"url":"#clientquerysubmittable","title":"client.query(Submittable)"}]}]}]},"parent":{"__typename":"File","relativePath":"guides/upgrading.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/announcements","title":"Announcements"}}},{"node":{"fields":{"slug":"/","title":"Welcome"}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Async Express"}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading"}}},{"node":{"fields":null}},{"node":{"fields":null}},{"node":{"fields":null}},{"node":{"fields":{"slug":"/api/result","title":"Result"}}},{"node":{"fields":{"slug":"/api/types","title":"Types"}}},{"node":{"fields":null}},{"node":{"fields":null}},{"node":{"fields":{"slug":"/features/3-pooling","title":"Pooling"}}},{"node":{"fields":{"slug":"/features/4-transactions","title":"Transactions"}}},{"node":{"fields":null}},{"node":{"fields":null}},{"node":{"fields":{"slug":"/features/7-native","title":"Native Bindings"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"0275f5cc-b71d-5f93-bd9d-e231a85901c5"}}